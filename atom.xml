<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HITvinci的博客</title>
  
  
  <link href="https://hitvinci.github.io/atom.xml" rel="self"/>
  
  <link href="https://hitvinci.github.io/"/>
  <updated>2023-10-05T14:28:09.969Z</updated>
  <id>https://hitvinci.github.io/</id>
  
  <author>
    <name>HITvinci</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【数据结构】队列的基本操作</title>
    <link href="https://hitvinci.github.io/2023/10/05/%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://hitvinci.github.io/2023/10/05/%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2023-10-05T11:28:50.466Z</published>
    <updated>2023-10-05T14:28:09.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列的特性是先进后出，即先进入队列的元素，最后出队列。<br>队列的实现方式有两种，一种是循环数组实现，另一种是指针实现。</p><span id="more"></span><p>目录：</p><ul><li><a href="#%E9%98%9F%E5%88%97">队列</a><ul><li><a href="#1-%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0">1. 循环数组实现</a></li><li><a href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0">2. 队列的指针实现</a></li><li><a href="#3-%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">3. 队列的初始化</a></li><li><a href="#4-%E5%85%A5%E9%98%9F%E5%88%97">4. 入队列</a></li><li><a href="#5-%E5%87%BA%E9%98%9F%E5%88%97">5. 出队列</a></li></ul></li></ul><h2 id="1-循环数组实现"><a href="#1-循环数组实现" class="headerlink" title="1. 循环数组实现"></a>1. 循环数组实现</h2><p>循环数组实现队列，需要一个首位置，一个末位置，还有一个数组。<br>以下是一循环数组创建的队列示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define maxlength 100</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int data[maxlength];</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h2 id="2-队列的指针实现"><a href="#2-队列的指针实现" class="headerlink" title="2. 队列的指针实现"></a>2. 队列的指针实现</h2><p>队列的指针实现，需要一个队列节点，还需要一个队列型。</p><p>队列与其他数据结构有一点不同，例如在栈的指针实现过程中，只需要一个栈顶指针，而在队列的指针实现中，需要两个指针，一个指向队列的头，一个指向队列的尾。所以队列需要单独定义一个结构体，而栈只需要一个结构体指针即可。</p><p>以下是一个队列节点的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct celltype&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct celltype *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个节点中有两个域，一个域为数据域，另一个域为指向下一个节点的指针。</p><p>以下是一个队列的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct QUEUE&#123;</span><br><span class="line">    struct celltype *front;</span><br><span class="line">    struct celltype *rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在队列中，front指向队列的头，rear指向队列的尾。</p><h2 id="3-队列的初始化"><a href="#3-队列的初始化" class="headerlink" title="3. 队列的初始化"></a>3. 队列的初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Init(QUEUE *Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front = (struct celltype *)malloc(sizeof(struct celltype));</span><br><span class="line">    Q.front-&gt;next=NULL; //创建一个空节点，并将其作为队列的头</span><br><span class="line">    Q.rear = Q.front; //将尾指针指向头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的初始化即为队列分配存储空间，并初始化front和rear。</p><h2 id="4-入队列"><a href="#4-入队列" class="headerlink" title="4. 入队列"></a>4. 入队列</h2><p>下面将介绍队列中两个比较重要的操作，一个是入队列，一个是出队列。(下文中的队列均指指针实现队列)<br>其中实现的方式为，先从队列的末尾插入元素，即先创建一个节点，然后将其插入到队列的末尾。当需要出队列的时候，从队列的头开始出队列。</p><p>下面是入队列的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push(QUEUE *Q, int x)</span><br><span class="line">&#123;</span><br><span class="line">    struct celltype *p;</span><br><span class="line">    p = (struct celltype *)malloc(sizeof(struct celltype)); // 创建新的节点，使其位于队列的末尾</span><br><span class="line">    p-&gt;data = x; // 将数据赋值给新节点</span><br><span class="line">    p-&gt;next = NULL; // 将新节点的指针域置空</span><br><span class="line">    Q-&gt;rear-&gt;next = p; // 将新节点插入到队列的末尾</span><br><span class="line">    Q-&gt;rear = p; // 将尾后指针指向新节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q-&gt;rear-&gt;next=p; //将新节点插入到队列的末尾</span><br><span class="line">Q-&gt;rear=p; //将尾后指针指向新节点</span><br></pre></td></tr></table></figure><p><strong>这两行代码做解释，解答为什么不能只写最后一行，而需要两行都写：</strong></p><p><strong>第一行是将新节点插入到队列的末尾，但是此时尾后指针并没有指向新节点，所以需要将尾后指针指向新节点。</strong><br><strong>第二行是将尾后指针指向新节点，此时新节点已经插入到队列的末尾，所以需要将尾后指针指向新节点。也就是说，Q-&gt;rear只是一个标志，他的存在就是为了得到最后一个节点的位置，而并不是固定的某个元素</strong></p><h2 id="5-出队列"><a href="#5-出队列" class="headerlink" title="5. 出队列"></a>5. 出队列</h2><p>下面是出队列的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void pop(QUEUE *Q,int *x)</span><br><span class="line">&#123;</span><br><span class="line">    struct celltype *p;</span><br><span class="line">    p=Q.front-&gt;next; //将队列的头节点的指针赋值给p</span><br><span class="line">    *x=p-&gt;data; //将p节点的数据赋值给x</span><br><span class="line">    Q.front-&gt;next=p-&gt;next; //将p节点的指针域赋值给队列的头节点的指针域</span><br><span class="line">    free(p); //释放p节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h1&gt;&lt;p&gt;队列的特性是先进后出，即先进入队列的元素，最后出队列。&lt;br&gt;队列的实现方式有两种，一种是循环数组实现，另一种是指针实现。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://hitvinci.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="队列" scheme="https://hitvinci.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】顺序栈</title>
    <link href="https://hitvinci.github.io/2023/10/05/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    <id>https://hitvinci.github.io/2023/10/05/%E9%A1%BA%E5%BA%8F%E6%A0%88/</id>
    <published>2023-10-05T11:28:50.462Z</published>
    <updated>2023-10-05T14:28:19.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>栈是一种数据结构，其主要特点是后进先出，相当于我们在瓶子里面放东西，后放进去的东西在上面，所以拿出来的时候自然是从上面取出来，所以后进去的先出来。<br>本文主要介绍的是栈的数组实现方法，即顺序栈。</p><span id="more"></span><p>目录：</p><ul><li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88">顺序栈</a><ul><li><a href="#1-%E6%A0%88%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA">1. 栈的数组实现（创建）</a><ul><li><a href="#11-%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.1. 栈的初始化</a></li><li><a href="#12-%E6%A0%88%E7%9A%84%E5%A2%9E%E5%8A%A0%E5%8E%8B%E6%A0%88">1.2. 栈的增加（压栈）</a></li><li><a href="#13-%E6%A0%88%E7%9A%84%E5%88%A0%E9%99%A4%E5%BC%B9%E6%A0%88">1.3. 栈的删除（弹栈）</a></li><li><a href="#14-%E6%A0%88%E7%9A%84%E6%9F%A5%E8%AF%A2">1.4. 栈的查询</a></li><li><a href="#15-%E6%A0%88%E7%9A%84%E5%88%A4%E7%A9%BA%E5%92%8C%E5%88%A4%E6%BB%A1">1.5. 栈的判空和判满</a></li></ul></li></ul></li></ul><p>基本操作有以下几种：</p><h2 id="1-栈的数组实现（创建）"><a href="#1-栈的数组实现（创建）" class="headerlink" title="1. 栈的数组实现（创建）"></a>1. 栈的数组实现（创建）</h2><p>栈的数组实现起来相对简单。在定义的时候，我们只需要定义一个结构体即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAXSIZE]; <span class="comment">// 创建最大长度的数组</span></span><br><span class="line">    <span class="type">int</span> top;          <span class="comment">// 当前顶部元素的位置</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure><p>栈的结构体中需要一个数组来存储元素，还需要一个变量来记录当前栈顶元素的位置。</p><h3 id="1-1-栈的初始化"><a href="#1-1-栈的初始化" class="headerlink" title="1.1. 栈的初始化"></a>1.1. 栈的初始化</h3><p>栈的初始化只需要让top为-1即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-栈的增加（压栈）"><a href="#1-2-栈的增加（压栈）" class="headerlink" title="1.2. 栈的增加（压栈）"></a>1.2. 栈的增加（压栈）</h3><p>压栈即将元素压入栈中，压栈的时候，我们需要给函数传递需要压栈的元素和栈本身。</p><p>在压栈之前我们还需要判断栈是否已经满，若未满即可进行压栈。</p><p>在压栈的过程中我们需要让top加一，即让栈顶元素的位置加一，然后让新的元素赋值到新的数组的top位置上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack &amp;S,<span class="type">char</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MAXSIZE<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，无法插入元素！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-栈的删除（弹栈）"><a href="#1-3-栈的删除（弹栈）" class="headerlink" title="1.3. 栈的删除（弹栈）"></a>1.3. 栈的删除（弹栈）</h3><p>当我们需要弹栈的时候，只需要返回数组top位置的元素，然后让top减一即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(Stack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S.data[S.top--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-栈的查询"><a href="#1-4-栈的查询" class="headerlink" title="1.4. 栈的查询"></a>1.4. 栈的查询</h3><p>由于栈的特性，我们在查询的时候一般查询栈的栈顶元素。当我们需要查询栈顶元素的时候，只需要返回数组top位置的元素即可。如果需要对栈的其他元素进行查询，需要逐个遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S.data[S.top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-栈的判空和判满"><a href="#1-5-栈的判空和判满" class="headerlink" title="1.5. 栈的判空和判满"></a>1.5. 栈的判空和判满</h3><p>栈的判空和比较简单，在判空时只需要判断top是否等于-1即可，在判满的时候只需要判断top是否等于MAXSIZE-1即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackFull</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==MAXSIZE<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h1&gt;&lt;p&gt;栈是一种数据结构，其主要特点是后进先出，相当于我们在瓶子里面放东西，后放进去的东西在上面，所以拿出来的时候自然是从上面取出来，所以后进去的先出来。&lt;br&gt;本文主要介绍的是栈的数组实现方法，即顺序栈。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://hitvinci.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="https://hitvinci.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Hi！朋友！</title>
    <link href="https://hitvinci.github.io/2023/10/04/Hi%EF%BC%81%E6%9C%8B%E5%8F%8B/"/>
    <id>https://hitvinci.github.io/2023/10/04/Hi%EF%BC%81%E6%9C%8B%E5%8F%8B/</id>
    <published>2023-10-04T03:05:24.530Z</published>
    <updated>2023-10-06T07:48:29.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎来访！"><a href="#欢迎来访！" class="headerlink" title="欢迎来访！"></a>欢迎来访！</h1><p>Hi！朋友！欢迎来到我的博客！作为一名初学者，这里以后将会更新我的学习总结和一些经验技术分享。<span id="more"></span>如果你对我的博客内容有任何问题，可以通过侧边栏的方式与我进行联系。文章内容均为原创，如果喜欢不妨支持一下，你的支持将会激励我的创作！</p><h1 id="网站搭建历程"><a href="#网站搭建历程" class="headerlink" title="网站搭建历程"></a>网站搭建历程</h1><p>本站是通过hexo框架和Next主题联合搭建的，我这个零基础初学者完全根据教程耗时约两天解决各种问题，最终呈现出这样一个博客页面。如果你对博客网站的搭建感兴趣，不妨点击<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a>进行类似我的博客网站的搭建。</p><h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul><li>10.4 建立博客网站并解析域名</li><li>10.5 进行基本美化，填充内容</li></ul><h1 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h1><ul><li>没能实现一打开博客就播放音乐</li><li>博客打开速度慢</li></ul><h1 id="其他闲话"><a href="#其他闲话" class="headerlink" title="其他闲话"></a>其他闲话</h1><p>通过博客的搭建，让我重新感受到了计算机对我的魅力，也让我拾起了学习计算机专业的初心：并不是要挣多少钱，也并不是要会敲多少代码，而是单纯的为了好玩儿！学计算机就是为了好玩，为了能够学习更多的计算机技术。会玩电脑，也能玩好电脑！</p><hr><p>暂时就这样，以后再补充！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;欢迎来访！&quot;&gt;&lt;a href=&quot;#欢迎来访！&quot; class=&quot;headerlink&quot; title=&quot;欢迎来访！&quot;&gt;&lt;/a&gt;欢迎来访！&lt;/h1&gt;&lt;p&gt;Hi！朋友！欢迎来到我的博客！作为一名初学者，这里以后将会更新我的学习总结和一些经验技术分享。</summary>
    
    
    
    
  </entry>
  
</feed>
