<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HITvinci的博客</title>
  
  
  <link href="https://hitvinci.github.io/atom.xml" rel="self"/>
  
  <link href="https://hitvinci.github.io/"/>
  <updated>2023-10-05T14:28:09.969Z</updated>
  <id>https://hitvinci.github.io/</id>
  
  <author>
    <name>HITvinci</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【数据结构】队列的基本操作</title>
    <link href="https://hitvinci.github.io/2023/10/05/%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://hitvinci.github.io/2023/10/05/%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2023-10-05T11:28:50.466Z</published>
    <updated>2023-10-05T14:28:09.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列的特性是先进后出，即先进入队列的元素，最后出队列。<br>队列的实现方式有两种，一种是循环数组实现，另一种是指针实现。</p><span id="more"></span><p>目录：</p><ul><li><a href="#%E9%98%9F%E5%88%97">队列</a><ul><li><a href="#1-%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0">1. 循环数组实现</a></li><li><a href="#2-%E9%98%9F%E5%88%97%E7%9A%84%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0">2. 队列的指针实现</a></li><li><a href="#3-%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">3. 队列的初始化</a></li><li><a href="#4-%E5%85%A5%E9%98%9F%E5%88%97">4. 入队列</a></li><li><a href="#5-%E5%87%BA%E9%98%9F%E5%88%97">5. 出队列</a></li></ul></li></ul><h2 id="1-循环数组实现"><a href="#1-循环数组实现" class="headerlink" title="1. 循环数组实现"></a>1. 循环数组实现</h2><p>循环数组实现队列，需要一个首位置，一个末位置，还有一个数组。<br>以下是一循环数组创建的队列示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define maxlength 100</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    int front;</span><br><span class="line">    int rear;</span><br><span class="line">    int data[maxlength];</span><br><span class="line">&#125;Queue;</span><br></pre></td></tr></table></figure><h2 id="2-队列的指针实现"><a href="#2-队列的指针实现" class="headerlink" title="2. 队列的指针实现"></a>2. 队列的指针实现</h2><p>队列的指针实现，需要一个队列节点，还需要一个队列型。</p><p>队列与其他数据结构有一点不同，例如在栈的指针实现过程中，只需要一个栈顶指针，而在队列的指针实现中，需要两个指针，一个指向队列的头，一个指向队列的尾。所以队列需要单独定义一个结构体，而栈只需要一个结构体指针即可。</p><p>以下是一个队列节点的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct celltype&#123;</span><br><span class="line">    int data;</span><br><span class="line">    struct celltype *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个节点中有两个域，一个域为数据域，另一个域为指向下一个节点的指针。</p><p>以下是一个队列的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct QUEUE&#123;</span><br><span class="line">    struct celltype *front;</span><br><span class="line">    struct celltype *rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在队列中，front指向队列的头，rear指向队列的尾。</p><h2 id="3-队列的初始化"><a href="#3-队列的初始化" class="headerlink" title="3. 队列的初始化"></a>3. 队列的初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Init(QUEUE *Q)</span><br><span class="line">&#123;</span><br><span class="line">    Q.front = (struct celltype *)malloc(sizeof(struct celltype));</span><br><span class="line">    Q.front-&gt;next=NULL; //创建一个空节点，并将其作为队列的头</span><br><span class="line">    Q.rear = Q.front; //将尾指针指向头指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的初始化即为队列分配存储空间，并初始化front和rear。</p><h2 id="4-入队列"><a href="#4-入队列" class="headerlink" title="4. 入队列"></a>4. 入队列</h2><p>下面将介绍队列中两个比较重要的操作，一个是入队列，一个是出队列。(下文中的队列均指指针实现队列)<br>其中实现的方式为，先从队列的末尾插入元素，即先创建一个节点，然后将其插入到队列的末尾。当需要出队列的时候，从队列的头开始出队列。</p><p>下面是入队列的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void push(QUEUE *Q, int x)</span><br><span class="line">&#123;</span><br><span class="line">    struct celltype *p;</span><br><span class="line">    p = (struct celltype *)malloc(sizeof(struct celltype)); // 创建新的节点，使其位于队列的末尾</span><br><span class="line">    p-&gt;data = x; // 将数据赋值给新节点</span><br><span class="line">    p-&gt;next = NULL; // 将新节点的指针域置空</span><br><span class="line">    Q-&gt;rear-&gt;next = p; // 将新节点插入到队列的末尾</span><br><span class="line">    Q-&gt;rear = p; // 将尾后指针指向新节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里对</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q-&gt;rear-&gt;next=p; //将新节点插入到队列的末尾</span><br><span class="line">Q-&gt;rear=p; //将尾后指针指向新节点</span><br></pre></td></tr></table></figure><p><strong>这两行代码做解释，解答为什么不能只写最后一行，而需要两行都写：</strong></p><p><strong>第一行是将新节点插入到队列的末尾，但是此时尾后指针并没有指向新节点，所以需要将尾后指针指向新节点。</strong><br><strong>第二行是将尾后指针指向新节点，此时新节点已经插入到队列的末尾，所以需要将尾后指针指向新节点。也就是说，Q-&gt;rear只是一个标志，他的存在就是为了得到最后一个节点的位置，而并不是固定的某个元素</strong></p><h2 id="5-出队列"><a href="#5-出队列" class="headerlink" title="5. 出队列"></a>5. 出队列</h2><p>下面是出队列的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void pop(QUEUE *Q,int *x)</span><br><span class="line">&#123;</span><br><span class="line">    struct celltype *p;</span><br><span class="line">    p=Q.front-&gt;next; //将队列的头节点的指针赋值给p</span><br><span class="line">    *x=p-&gt;data; //将p节点的数据赋值给x</span><br><span class="line">    Q.front-&gt;next=p-&gt;next; //将p节点的指针域赋值给队列的头节点的指针域</span><br><span class="line">    free(p); //释放p节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h1&gt;&lt;p&gt;队列的特性是先进后出，即先进入队列的元素，最后出队列。&lt;br&gt;队列的实现方式有两种，一种是循环数组实现，另一种是指针实现。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://hitvinci.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="队列" scheme="https://hitvinci.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】单链表</title>
    <link href="https://hitvinci.github.io/2023/10/05/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://hitvinci.github.io/2023/10/05/%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2023-10-05T11:28:50.464Z</published>
    <updated>2023-10-05T14:28:27.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>链表是一种基本的数据结构，在很多数据结构中都会使用链表的方式进行建立，所以将链表学会学通透很有必要。</p><span id="more"></span><p>目录：</p><ul><li><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8">单链表</a><ul><li><a href="#1-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">1. 链表的定义</a></li><li><a href="#2-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E5%8C%96">2. 链表的创建（初始化）</a><ul><li><a href="#21-%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8">2.1. 不带头结点的链表</a></li><li><a href="#22-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E9%93%BE%E8%A1%A8">2.2. 带头结点的链表</a></li></ul></li><li><a href="#3-%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">3. 链表的插入和删除</a><ul><li><a href="#31-%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5">3.1. 按位序插入</a><ul><li><a href="#311-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9">3.1.1. 带头结点</a></li><li><a href="#312-%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9">3.1.2. 不带头结点</a></li></ul></li><li><a href="#32-%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E6%8F%92%E6%93%8D%E4%BD%9C">3.2. 指定节点的后插操作</a></li><li><a href="#33-%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C">3.3. 指定元素的前插操作</a></li><li><a href="#34-%E6%8C%89%E4%BD%8D%E5%BA%8F%E5%88%A0%E9%99%A4">3.4. 按位序删除</a><ul><li><a href="#341-%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9">3.4.1. 带头结点</a></li><li><a href="#342-%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9">3.4.2. 不带头结点</a></li></ul></li><li><a href="#35-%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C">3.5. 指定元素的删除操作</a></li></ul></li></ul></li></ul><h2 id="1-链表的定义"><a href="#1-链表的定义" class="headerlink" title="1. 链表的定义"></a>1. 链表的定义</h2><p>链表的定义是基于结构体之上的，一个链表一般需要定义两方面的东西，一个是链表的节点，一个是链表的指针。一个链表的定义示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*List;</span><br></pre></td></tr></table></figure><p>上述代码中的val是数据域，用来存放数据，next是指针域，用来存放下一个节点的地址。<br>并且该代码采用了typedef定义了一个别名LNode，用来指代链表的节点，List是链表的指针，用来指向链表的第一个节点。</p><h2 id="2-链表的创建（初始化）"><a href="#2-链表的创建（初始化）" class="headerlink" title="2. 链表的创建（初始化）"></a>2. 链表的创建（初始化）</h2><p>链表的创建有两种方式，一种是带头结点的，另一种是不带头节点的。</p><h3 id="2-1-不带头结点的链表"><a href="#2-1-不带头结点的链表" class="headerlink" title="2.1. 不带头结点的链表"></a>2.1. 不带头结点的链表</h3><p>不带头结点的链表的创建方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(List *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使得链表的下一个节点为空。</p><h3 id="2-2-带头结点的链表"><a href="#2-2-带头结点的链表" class="headerlink" title="2.2. 带头结点的链表"></a>2.2. 带头结点的链表</h3><p>带头结点的链表的创建方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(List *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    L=(List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;<span class="comment">//此时表示创建头结点失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//头结点指向的下一个节点为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头结点的好处就在于，当我们需要对链表进行一个操作的时候，不需要专门对链表的第一个节点进行特殊操作，我们只需要对所有的代码编写一个固定的函数，通过传递不同的值就可以实现特定高度功能。</p><h2 id="3-链表的插入和删除"><a href="#3-链表的插入和删除" class="headerlink" title="3. 链表的插入和删除"></a>3. 链表的插入和删除</h2><h3 id="3-1-按位序插入"><a href="#3-1-按位序插入" class="headerlink" title="3.1. 按位序插入"></a>3.1. 按位序插入</h3><h4 id="3-1-1-带头结点"><a href="#3-1-1-带头结点" class="headerlink" title="3.1.1. 带头结点"></a>3.1.1. 带头结点</h4><p>链表的插入，需要先找到要插入位置的前后节点，然后创建一个指针，使得前一个节点指向这个指针，这个指针再指向下一个节点。</p><p>在按位序插入的过程中，我们需要输入链表的头结点（供遍历寻找目标位置），要插入的位置和元素。<br>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(List *L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p; <span class="comment">//p表示当前指向的是哪个节点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>; <span class="comment">//j表示的是当前指向节点的位置</span></span><br><span class="line">    p=L; <span class="comment">//目前先让p指向头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>) <span class="comment">//循环找到要插入节点的前一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s.data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-不带头结点"><a href="#3-1-2-不带头结点" class="headerlink" title="3.1.2. 不带头结点"></a>3.1.2. 不带头结点</h4><p>不带头结点的插入与带头结点的插入类似，但是相对带头节点来说更加繁琐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(List *L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LNode *q=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        q-&gt;data=e;</span><br><span class="line">        q-&gt;next=L;</span><br><span class="line">        L=q;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p; <span class="comment">//p表示当前指向的是哪个节点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>; <span class="comment">//j表示的是当前指向节点的位置</span></span><br><span class="line">    p=L; <span class="comment">//目前先让p指向头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>) <span class="comment">//循环找到要插入节点的前一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s.data=e;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样传入的是第一个节点的地址，要加入节点的位置和要加入的元素，区别就在于加入要在第一个位置插入元素，就需要特别处理一下。</p><h3 id="3-2-指定节点的后插操作"><a href="#3-2-指定节点的后插操作" class="headerlink" title="3.2. 指定节点的后插操作"></a>3.2. 指定节点的后插操作</h3><p>在给定节点后插入节点的操作相对简单，示例代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s=&gt;data=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-指定元素的前插操作"><a href="#3-3-指定元素的前插操作" class="headerlink" title="3.3. 指定元素的前插操作"></a>3.3. 指定元素的前插操作</h3><p>在指定元素之前要插入一个元素，最容易想到的办法是将整个链表遍历一遍，之后找到这个元素的前驱节点，转换成后插操作。但是这种办法实现起来较为复杂，所以我们转换一种思维方式，采取新的方法。</p><p>我们尝试在指定节点之后先插入一个节点，然后把指定节点的值赋给新节点，之后再把要插入的值赋给旧节点。总而言之就是现在之后插入节点，然后把两个节点的值互换，就相当于将前后节点互换了。示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    s-&gt;data=p-&gt;data;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-按位序删除"><a href="#3-4-按位序删除" class="headerlink" title="3.4. 按位序删除"></a>3.4. 按位序删除</h3><h4 id="3-4-1-带头结点"><a href="#3-4-1-带头结点" class="headerlink" title="3.4.1. 带头结点"></a>3.4.1. 带头结点</h4><p>在带头结点的删除节点操作中，我们需要给函数传递链表的第一个节点的位置，要删除的位置和一个变量用来存储删除节点的元素值。</p><p>删除的主要操作是创建一个指针(不分配内存空间)指向要删除的节点，然后让要删除指针前一个节点指向要删除指针的后一个节点，然后将要删除的指针释放内存，从而达到目的。</p><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(List L,<span class="type">int</span> i,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>;j&lt;i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *q=p-&gt;next;</span><br><span class="line">    x=q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-不带头结点"><a href="#3-4-2-不带头结点" class="headerlink" title="3.4.2. 不带头结点"></a>3.4.2. 不带头结点</h4><p>与不带头结点的插入类似，这里不再赘述。</p><h3 id="3-5-指定元素的删除操作"><a href="#3-5-指定元素的删除操作" class="headerlink" title="3.5. 指定元素的删除操作"></a>3.5. 指定元素的删除操作</h3><p>删除操作和带头结点的的相似，指定元素和指定元素的插入相似，这里不再赘述！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h1&gt;&lt;p&gt;链表是一种基本的数据结构，在很多数据结构中都会使用链表的方式进行建立，所以将链表学会学通透很有必要。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://hitvinci.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="链表" scheme="https://hitvinci.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】顺序栈</title>
    <link href="https://hitvinci.github.io/2023/10/05/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    <id>https://hitvinci.github.io/2023/10/05/%E9%A1%BA%E5%BA%8F%E6%A0%88/</id>
    <published>2023-10-05T11:28:50.462Z</published>
    <updated>2023-10-05T14:28:19.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>栈是一种数据结构，其主要特点是后进先出，相当于我们在瓶子里面放东西，后放进去的东西在上面，所以拿出来的时候自然是从上面取出来，所以后进去的先出来。<br>本文主要介绍的是栈的数组实现方法，即顺序栈。</p><span id="more"></span><p>目录：</p><ul><li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88">顺序栈</a><ul><li><a href="#1-%E6%A0%88%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA">1. 栈的数组实现（创建）</a><ul><li><a href="#11-%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.1. 栈的初始化</a></li><li><a href="#12-%E6%A0%88%E7%9A%84%E5%A2%9E%E5%8A%A0%E5%8E%8B%E6%A0%88">1.2. 栈的增加（压栈）</a></li><li><a href="#13-%E6%A0%88%E7%9A%84%E5%88%A0%E9%99%A4%E5%BC%B9%E6%A0%88">1.3. 栈的删除（弹栈）</a></li><li><a href="#14-%E6%A0%88%E7%9A%84%E6%9F%A5%E8%AF%A2">1.4. 栈的查询</a></li><li><a href="#15-%E6%A0%88%E7%9A%84%E5%88%A4%E7%A9%BA%E5%92%8C%E5%88%A4%E6%BB%A1">1.5. 栈的判空和判满</a></li></ul></li></ul></li></ul><p>基本操作有以下几种：</p><h2 id="1-栈的数组实现（创建）"><a href="#1-栈的数组实现（创建）" class="headerlink" title="1. 栈的数组实现（创建）"></a>1. 栈的数组实现（创建）</h2><p>栈的数组实现起来相对简单。在定义的时候，我们只需要定义一个结构体即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAXSIZE]; <span class="comment">// 创建最大长度的数组</span></span><br><span class="line">    <span class="type">int</span> top;          <span class="comment">// 当前顶部元素的位置</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure><p>栈的结构体中需要一个数组来存储元素，还需要一个变量来记录当前栈顶元素的位置。</p><h3 id="1-1-栈的初始化"><a href="#1-1-栈的初始化" class="headerlink" title="1.1. 栈的初始化"></a>1.1. 栈的初始化</h3><p>栈的初始化只需要让top为-1即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-栈的增加（压栈）"><a href="#1-2-栈的增加（压栈）" class="headerlink" title="1.2. 栈的增加（压栈）"></a>1.2. 栈的增加（压栈）</h3><p>压栈即将元素压入栈中，压栈的时候，我们需要给函数传递需要压栈的元素和栈本身。</p><p>在压栈之前我们还需要判断栈是否已经满，若未满即可进行压栈。</p><p>在压栈的过程中我们需要让top加一，即让栈顶元素的位置加一，然后让新的元素赋值到新的数组的top位置上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack &amp;S,<span class="type">char</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MAXSIZE<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，无法插入元素！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S.top++;</span><br><span class="line">    S.data[S.top]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-栈的删除（弹栈）"><a href="#1-3-栈的删除（弹栈）" class="headerlink" title="1.3. 栈的删除（弹栈）"></a>1.3. 栈的删除（弹栈）</h3><p>当我们需要弹栈的时候，只需要返回数组top位置的元素，然后让top减一即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(Stack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S.data[S.top--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-栈的查询"><a href="#1-4-栈的查询" class="headerlink" title="1.4. 栈的查询"></a>1.4. 栈的查询</h3><p>由于栈的特性，我们在查询的时候一般查询栈的栈顶元素。当我们需要查询栈顶元素的时候，只需要返回数组top位置的元素即可。如果需要对栈的其他元素进行查询，需要逐个遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> S.data[S.top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-栈的判空和判满"><a href="#1-5-栈的判空和判满" class="headerlink" title="1.5. 栈的判空和判满"></a>1.5. 栈的判空和判满</h3><p>栈的判空和比较简单，在判空时只需要判断top是否等于-1即可，在判满的时候只需要判断top是否等于MAXSIZE-1即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">StackFull</span><span class="params">(Stack S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top==MAXSIZE<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h1&gt;&lt;p&gt;栈是一种数据结构，其主要特点是后进先出，相当于我们在瓶子里面放东西，后放进去的东西在上面，所以拿出来的时候自然是从上面取出来，所以后进去的先出来。&lt;br&gt;本文主要介绍的是栈的数组实现方法，即顺序栈。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://hitvinci.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="栈" scheme="https://hitvinci.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Hi！朋友！</title>
    <link href="https://hitvinci.github.io/2023/10/04/Hi%EF%BC%81%E6%9C%8B%E5%8F%8B/"/>
    <id>https://hitvinci.github.io/2023/10/04/Hi%EF%BC%81%E6%9C%8B%E5%8F%8B/</id>
    <published>2023-10-04T03:05:24.530Z</published>
    <updated>2023-10-05T14:18:38.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎来访！"><a href="#欢迎来访！" class="headerlink" title="欢迎来访！"></a>欢迎来访！</h1><p>Hi！朋友！欢迎来到我的博客！作为一名初学者，这里以后将会更新我的学习总结和一些经验技术分享。<span id="more"></span>如果你对我的博客内容有任何问题，可以通过侧边栏的方式与我进行联系。文章内容均为原创，如果喜欢不妨支持一下，你的支持将会激励我的创作！</p><h1 id="网站搭建历程"><a href="#网站搭建历程" class="headerlink" title="网站搭建历程"></a>网站搭建历程</h1><p>本站是通过hexo框架和Next主题联合搭建的，我这个零基础初学者完全根据教程耗时约两天解决各种问题，最终呈现出这样一个博客页面。如果你对博客网站的搭建感兴趣，不妨点击<a href="https://zhuanlan.zhihu.com/p/102592286">https://zhuanlan.zhihu.com/p/102592286</a>进行类似我的博客网站的搭建。</p><h1 id="其他闲话"><a href="#其他闲话" class="headerlink" title="其他闲话"></a>其他闲话</h1><p>通过博客的搭建，让我重新感受到了计算机对我的魅力，也让我拾起了学习计算机专业的初心：并不是要挣多少钱，也并不是要会敲多少代码，而是单纯的为了好玩儿！学计算机就是为了好玩，为了能够学习更多的计算机技术。会玩电脑，也能玩好电脑！</p><hr><p>暂时就这样，以后再补充！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;欢迎来访！&quot;&gt;&lt;a href=&quot;#欢迎来访！&quot; class=&quot;headerlink&quot; title=&quot;欢迎来访！&quot;&gt;&lt;/a&gt;欢迎来访！&lt;/h1&gt;&lt;p&gt;Hi！朋友！欢迎来到我的博客！作为一名初学者，这里以后将会更新我的学习总结和一些经验技术分享。</summary>
    
    
    
    
  </entry>
  
</feed>
